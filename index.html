<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D ç‹—ç‹—èŠå¤©èˆ‡æŒçºŒå‹•ä½œç‰ˆ</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body style="margin:0; overflow:hidden;">
    <div id="chatbox" style="position:fixed; bottom:20px; left:20px; background:#fff; padding:10px; border-radius:8px;">
        <input type="text" id="userInput" placeholder="è¼¸å…¥å•é¡Œæˆ– /æŒ‡ä»¤..." style="width:200px;">
        <button onclick="askDog()">é€å‡º</button>
        <div id="dogResponse" style="margin-top:10px; font-family:monospace;"></div>
    </div>

    <div id="actionbox" style="position:fixed; top:50px; right:20px; background:#fff; padding:10px; border-radius:8px;">
        <button onclick="performDogAction('head_pat')">æ‘¸é ­</button><br><br>
        <button onclick="performDogAction('wave_paw')">æŠ¬æ‰‹</button><br><br>
        <button onclick="performDogAction('spin')">è½‰åœˆ</button><br><br>
        <button onclick="performDogAction('sit')">åä¸‹</button><br><br>
        <button onclick="performDogAction('beg')">æ’’å¬Œ</button>
    </div>

    <script>
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const light = new THREE.PointLight(0xffffff, 1, 100);
        light.position.set(10, 10, 10);
        scene.add(light);
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);

        camera.position.z = 5;

        let currentAnimationId = null;

        function createDog() {
            const group = new THREE.Group();
            const body = new THREE.Mesh(new THREE.BoxGeometry(1.5, 1, 1), new THREE.MeshPhongMaterial({ color: 0xa0522d }));
            group.add(body);

            const tail = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.05, 0.5), new THREE.MeshPhongMaterial({ color: 0x8b4513 }));
            tail.position.set(-0.8, 0.2, 0);
            tail.rotation.z = Math.PI / 4;
            tail.name = "tail";
            group.add(tail);

            const head = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.8, 0.8), new THREE.MeshPhongMaterial({ color: 0xd2b48c }));
            head.position.set(0.8, 0.3, 0);
            head.name = "head";
            group.add(head);

            const legGeometry = new THREE.BoxGeometry(0.2, 0.6, 0.2);
            const legMaterial = new THREE.MeshPhongMaterial({ color: 0x8b4513 });

            const frontLeftLeg = new THREE.Mesh(legGeometry, legMaterial);
            frontLeftLeg.position.set(0.4, -0.8, 0.3);
            frontLeftLeg.name = "frontLeftLeg";
            group.add(frontLeftLeg);

            const frontRightLeg = new THREE.Mesh(legGeometry, legMaterial);
            frontRightLeg.position.set(0.4, -0.8, -0.3);
            frontRightLeg.name = "frontRightLeg";
            group.add(frontRightLeg);

            const backLeftLeg = new THREE.Mesh(legGeometry, legMaterial);
            backLeftLeg.position.set(-0.4, -0.8, 0.3);
            backLeftLeg.name = "backLeftLeg";
            group.add(backLeftLeg);

            const backRightLeg = new THREE.Mesh(legGeometry, legMaterial);
            backRightLeg.position.set(-0.4, -0.8, -0.3);
            backRightLeg.name = "backRightLeg";
            group.add(backRightLeg);

            return group;
        }

        const dog = createDog();
        scene.add(dog);

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        animate();

        function analyzeBehavior(responseText) {
            const text = responseText.toLowerCase();
            if (text.includes("happy") || text.includes("glad") || text.includes("é–‹å¿ƒ")) return "wag_tail";
            if (text.includes("sleep") || text.includes("tired") || text.includes("ç´¯")) return "lie_down";
            if (text.includes("excited") || text.includes("jump") || text.includes("èˆˆå¥®")) return "jump";
            if (text.includes("think") || text.includes("wonder") || text.includes("æ€è€ƒ")) return "head_tilt";
            return "idle";
        }

        async function askDog() {
            const input = document.getElementById("userInput").value.trim();
            document.getElementById("dogResponse").innerText = "æ€è€ƒä¸­...";

            const commandMap = {
                "sit": "sit",
                "åä¸‹": "sit",
                "jump": "jump",
                "è·³èº": "jump",
                "wag_tail": "wag_tail",
                "æ–å°¾å·´": "wag_tail",
                "spin": "spin",
                "è½‰åœˆ": "spin",
                "beg": "beg",
                "æ’’å¬Œ": "beg",
                "wave_paw": "wave_paw",
                "æŠ¬æ‰‹": "wave_paw"
            };

            if (input.startsWith('/')) {
                const commandKey = input.slice(1);
                const action = commandMap[commandKey];
                if (action) {
                    performDogAction(action);
                    document.getElementById("dogResponse").innerText = `ğŸ¶ åŸ·è¡ŒæŒ‡ä»¤ï¼šã€Œ${commandKey}ã€`;
                } else {
                    document.getElementById("dogResponse").innerText = `ğŸ¶ æ²’æœ‰æ‰¾åˆ°é€™å€‹æŒ‡ä»¤ï¼šã€Œ${commandKey}ã€`;
                }
                return;
            }

            const response = await fetch("http://localhost:5000/ask", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ message: input })
            });
            const data = await response.json();
            document.getElementById("dogResponse").innerText = "ç‹—ç‹—èªª: " + data.reply;
            const behavior = analyzeBehavior(data.reply);
            performDogAction(behavior);
        }

        function performDogAction(action) {
            if (currentAnimationId) {
                cancelAnimationFrame(currentAnimationId);
                currentAnimationId = null;
            }

            const tail = dog.getObjectByName("tail");
            const head = dog.getObjectByName("head");
            const frontLeftLeg = dog.getObjectByName("frontLeftLeg");
            const frontRightLeg = dog.getObjectByName("frontRightLeg");
            if (!tail || !head) return;

            if (action === "wag_tail") {
                let angle = 0;
                function wag() {
                    angle += 0.2;
                    tail.rotation.y = Math.sin(angle) * 0.5;
                    currentAnimationId = requestAnimationFrame(wag);
                }
                wag();
            } else if (action === "lie_down") {
                dog.rotation.x = Math.PI / 2;
            } else if (action === "jump") {
                let up = true;
                function jump() {
                    if (dog.position.y >= 1) up = false;
                    if (dog.position.y <= 0) up = true;
                    dog.position.y += up ? 0.05 : -0.05;
                    currentAnimationId = requestAnimationFrame(jump);
                }
                jump();
            } else if (action === "head_tilt") {
                let angle = 0;
                function tilt() {
                    angle += 0.02;
                    head.rotation.z = Math.sin(angle) * 0.3;
                    currentAnimationId = requestAnimationFrame(tilt);
                }
                tilt();
            } else if (action === "head_pat") {
                head.scale.set(1.2, 0.8, 1.2);
                setTimeout(() => head.scale.set(1, 1, 1), 500);
            } else if (action === "wave_paw") {
                if (frontLeftLeg) {
                    frontLeftLeg.rotation.z = -Math.PI / 3;
                    setTimeout(() => frontLeftLeg.rotation.z = 0, 500);
                }
            } else if (action === "spin") {
                function spin() {
                    dog.rotation.y += 0.05;
                    currentAnimationId = requestAnimationFrame(spin);
                }
                spin();
            } else if (action === "sit") {
                dog.scale.y = 0.5;
                setTimeout(() => dog.scale.y = 1, 1000);
            } else if (action === "beg") {
                if (frontLeftLeg && frontRightLeg && tail) {
                    frontLeftLeg.rotation.z = -Math.PI / 2.5;
                    frontRightLeg.rotation.z = Math.PI / 2.5;
                    let wagAngle = 0;
                    function wagTailWhileBegging() {
                        wagAngle += 0.3;
                        tail.rotation.y = Math.sin(wagAngle) * 0.5;
                        currentAnimationId = requestAnimationFrame(wagTailWhileBegging);
                    }
                    wagTailWhileBegging();
                    setTimeout(() => {
                        frontLeftLeg.rotation.z = 0;
                        frontRightLeg.rotation.z = 0;
                    }, 1000);
                }
            }
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>